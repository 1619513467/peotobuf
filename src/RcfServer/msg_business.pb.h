// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: msg_business.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_msg_5fbusiness_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_msg_5fbusiness_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 3021000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4022003 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_msg_5fbusiness_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_msg_5fbusiness_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_msg_5fbusiness_2eproto;
namespace msg {
namespace business {
class GetItemRule;
struct GetItemRuleDefaultTypeInternal;
extern GetItemRuleDefaultTypeInternal _GetItemRule_default_instance_;
class ItemCheckResult;
struct ItemCheckResultDefaultTypeInternal;
extern ItemCheckResultDefaultTypeInternal _ItemCheckResult_default_instance_;
class ItemControlState;
struct ItemControlStateDefaultTypeInternal;
extern ItemControlStateDefaultTypeInternal _ItemControlState_default_instance_;
class ItemRule;
struct ItemRuleDefaultTypeInternal;
extern ItemRuleDefaultTypeInternal _ItemRule_default_instance_;
class ItemRules;
struct ItemRulesDefaultTypeInternal;
extern ItemRulesDefaultTypeInternal _ItemRules_default_instance_;
}  // namespace business
}  // namespace msg
PROTOBUF_NAMESPACE_OPEN
template <>
::msg::business::GetItemRule* Arena::CreateMaybeMessage<::msg::business::GetItemRule>(Arena*);
template <>
::msg::business::ItemCheckResult* Arena::CreateMaybeMessage<::msg::business::ItemCheckResult>(Arena*);
template <>
::msg::business::ItemControlState* Arena::CreateMaybeMessage<::msg::business::ItemControlState>(Arena*);
template <>
::msg::business::ItemRule* Arena::CreateMaybeMessage<::msg::business::ItemRule>(Arena*);
template <>
::msg::business::ItemRules* Arena::CreateMaybeMessage<::msg::business::ItemRules>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace msg {
namespace business {
enum ItemRule_ItemRuleType : int {
  ItemRule_ItemRuleType_T_SETRULE = 0,
  ItemRule_ItemRuleType_T_EXTEND = 1,
  ItemRule_ItemRuleType_ItemRule_ItemRuleType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ItemRule_ItemRuleType_ItemRule_ItemRuleType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ItemRule_ItemRuleType_IsValid(int value);
constexpr ItemRule_ItemRuleType ItemRule_ItemRuleType_ItemRuleType_MIN = static_cast<ItemRule_ItemRuleType>(0);
constexpr ItemRule_ItemRuleType ItemRule_ItemRuleType_ItemRuleType_MAX = static_cast<ItemRule_ItemRuleType>(1);
constexpr int ItemRule_ItemRuleType_ItemRuleType_ARRAYSIZE = 1 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
ItemRule_ItemRuleType_descriptor();
template <typename T>
const std::string& ItemRule_ItemRuleType_Name(T value) {
  static_assert(std::is_same<T, ItemRule_ItemRuleType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ItemRuleType_Name().");
  return ItemRule_ItemRuleType_Name(static_cast<ItemRule_ItemRuleType>(value));
}
template <>
inline const std::string& ItemRule_ItemRuleType_Name(ItemRule_ItemRuleType value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<ItemRule_ItemRuleType_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool ItemRule_ItemRuleType_Parse(absl::string_view name, ItemRule_ItemRuleType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ItemRule_ItemRuleType>(
      ItemRule_ItemRuleType_descriptor(), name, value);
}
enum ItemRule_ValueType : int {
  ItemRule_ValueType_T_STRING = 0,
  ItemRule_ValueType_T_DECIMAL = 1,
  ItemRule_ValueType_ItemRule_ValueType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ItemRule_ValueType_ItemRule_ValueType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ItemRule_ValueType_IsValid(int value);
constexpr ItemRule_ValueType ItemRule_ValueType_ValueType_MIN = static_cast<ItemRule_ValueType>(0);
constexpr ItemRule_ValueType ItemRule_ValueType_ValueType_MAX = static_cast<ItemRule_ValueType>(1);
constexpr int ItemRule_ValueType_ValueType_ARRAYSIZE = 1 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
ItemRule_ValueType_descriptor();
template <typename T>
const std::string& ItemRule_ValueType_Name(T value) {
  static_assert(std::is_same<T, ItemRule_ValueType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ValueType_Name().");
  return ItemRule_ValueType_Name(static_cast<ItemRule_ValueType>(value));
}
template <>
inline const std::string& ItemRule_ValueType_Name(ItemRule_ValueType value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<ItemRule_ValueType_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool ItemRule_ValueType_Parse(absl::string_view name, ItemRule_ValueType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ItemRule_ValueType>(
      ItemRule_ValueType_descriptor(), name, value);
}
enum ItemCheckResult_ResultType : int {
  ItemCheckResult_ResultType_T_PROGRESS = 0,
  ItemCheckResult_ResultType_T_RESULT = 1,
  ItemCheckResult_ResultType_ItemCheckResult_ResultType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ItemCheckResult_ResultType_ItemCheckResult_ResultType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ItemCheckResult_ResultType_IsValid(int value);
constexpr ItemCheckResult_ResultType ItemCheckResult_ResultType_ResultType_MIN = static_cast<ItemCheckResult_ResultType>(0);
constexpr ItemCheckResult_ResultType ItemCheckResult_ResultType_ResultType_MAX = static_cast<ItemCheckResult_ResultType>(1);
constexpr int ItemCheckResult_ResultType_ResultType_ARRAYSIZE = 1 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
ItemCheckResult_ResultType_descriptor();
template <typename T>
const std::string& ItemCheckResult_ResultType_Name(T value) {
  static_assert(std::is_same<T, ItemCheckResult_ResultType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ResultType_Name().");
  return ItemCheckResult_ResultType_Name(static_cast<ItemCheckResult_ResultType>(value));
}
template <>
inline const std::string& ItemCheckResult_ResultType_Name(ItemCheckResult_ResultType value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<ItemCheckResult_ResultType_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool ItemCheckResult_ResultType_Parse(absl::string_view name, ItemCheckResult_ResultType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ItemCheckResult_ResultType>(
      ItemCheckResult_ResultType_descriptor(), name, value);
}
enum ItemControlState_ControlStateType : int {
  ItemControlState_ControlStateType_T_UNKNOWN = 0,
  ItemControlState_ControlStateType_T_START = 1,
  ItemControlState_ControlStateType_T_STOP = 2,
  ItemControlState_ControlStateType_T_SUSPEND = 3,
  ItemControlState_ControlStateType_T_RESTORE = 4,
  ItemControlState_ControlStateType_ItemControlState_ControlStateType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ItemControlState_ControlStateType_ItemControlState_ControlStateType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ItemControlState_ControlStateType_IsValid(int value);
constexpr ItemControlState_ControlStateType ItemControlState_ControlStateType_ControlStateType_MIN = static_cast<ItemControlState_ControlStateType>(0);
constexpr ItemControlState_ControlStateType ItemControlState_ControlStateType_ControlStateType_MAX = static_cast<ItemControlState_ControlStateType>(4);
constexpr int ItemControlState_ControlStateType_ControlStateType_ARRAYSIZE = 4 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
ItemControlState_ControlStateType_descriptor();
template <typename T>
const std::string& ItemControlState_ControlStateType_Name(T value) {
  static_assert(std::is_same<T, ItemControlState_ControlStateType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ControlStateType_Name().");
  return ItemControlState_ControlStateType_Name(static_cast<ItemControlState_ControlStateType>(value));
}
template <>
inline const std::string& ItemControlState_ControlStateType_Name(ItemControlState_ControlStateType value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<ItemControlState_ControlStateType_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool ItemControlState_ControlStateType_Parse(absl::string_view name, ItemControlState_ControlStateType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ItemControlState_ControlStateType>(
      ItemControlState_ControlStateType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class GetItemRule final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.business.GetItemRule) */ {
 public:
  inline GetItemRule() : GetItemRule(nullptr) {}
  ~GetItemRule() override;
  explicit PROTOBUF_CONSTEXPR GetItemRule(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetItemRule(const GetItemRule& from);
  GetItemRule(GetItemRule&& from) noexcept
    : GetItemRule() {
    *this = ::std::move(from);
  }

  inline GetItemRule& operator=(const GetItemRule& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetItemRule& operator=(GetItemRule&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetItemRule& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetItemRule* internal_default_instance() {
    return reinterpret_cast<const GetItemRule*>(
               &_GetItemRule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(GetItemRule& a, GetItemRule& b) {
    a.Swap(&b);
  }
  inline void Swap(GetItemRule* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetItemRule* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetItemRule* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetItemRule>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetItemRule& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetItemRule& from) {
    GetItemRule::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetItemRule* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "msg.business.GetItemRule";
  }
  protected:
  explicit GetItemRule(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemIdFieldNumber = 1,
  };
  // uint32 item_id = 1;
  void clear_item_id() ;
  ::uint32_t item_id() const;
  void set_item_id(::uint32_t value);

  private:
  ::uint32_t _internal_item_id() const;
  void _internal_set_item_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:msg.business.GetItemRule)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::uint32_t item_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_5fbusiness_2eproto;
};// -------------------------------------------------------------------

class ItemRule final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.business.ItemRule) */ {
 public:
  inline ItemRule() : ItemRule(nullptr) {}
  ~ItemRule() override;
  explicit PROTOBUF_CONSTEXPR ItemRule(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ItemRule(const ItemRule& from);
  ItemRule(ItemRule&& from) noexcept
    : ItemRule() {
    *this = ::std::move(from);
  }

  inline ItemRule& operator=(const ItemRule& from) {
    CopyFrom(from);
    return *this;
  }
  inline ItemRule& operator=(ItemRule&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ItemRule& default_instance() {
    return *internal_default_instance();
  }
  static inline const ItemRule* internal_default_instance() {
    return reinterpret_cast<const ItemRule*>(
               &_ItemRule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ItemRule& a, ItemRule& b) {
    a.Swap(&b);
  }
  inline void Swap(ItemRule* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ItemRule* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ItemRule* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ItemRule>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ItemRule& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ItemRule& from) {
    ItemRule::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ItemRule* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "msg.business.ItemRule";
  }
  protected:
  explicit ItemRule(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using ItemRuleType = ItemRule_ItemRuleType;
  static constexpr ItemRuleType T_SETRULE = ItemRule_ItemRuleType_T_SETRULE;
  static constexpr ItemRuleType T_EXTEND = ItemRule_ItemRuleType_T_EXTEND;
  static inline bool ItemRuleType_IsValid(int value) {
    return ItemRule_ItemRuleType_IsValid(value);
  }
  static constexpr ItemRuleType ItemRuleType_MIN = ItemRule_ItemRuleType_ItemRuleType_MIN;
  static constexpr ItemRuleType ItemRuleType_MAX = ItemRule_ItemRuleType_ItemRuleType_MAX;
  static constexpr int ItemRuleType_ARRAYSIZE = ItemRule_ItemRuleType_ItemRuleType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ItemRuleType_descriptor() {
    return ItemRule_ItemRuleType_descriptor();
  }
  template <typename T>
  static inline const std::string& ItemRuleType_Name(T value) {
    return ItemRule_ItemRuleType_Name(value);
  }
  static inline bool ItemRuleType_Parse(absl::string_view name, ItemRuleType* value) {
    return ItemRule_ItemRuleType_Parse(name, value);
  }

  using ValueType = ItemRule_ValueType;
  static constexpr ValueType T_STRING = ItemRule_ValueType_T_STRING;
  static constexpr ValueType T_DECIMAL = ItemRule_ValueType_T_DECIMAL;
  static inline bool ValueType_IsValid(int value) {
    return ItemRule_ValueType_IsValid(value);
  }
  static constexpr ValueType ValueType_MIN = ItemRule_ValueType_ValueType_MIN;
  static constexpr ValueType ValueType_MAX = ItemRule_ValueType_ValueType_MAX;
  static constexpr int ValueType_ARRAYSIZE = ItemRule_ValueType_ValueType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ValueType_descriptor() {
    return ItemRule_ValueType_descriptor();
  }
  template <typename T>
  static inline const std::string& ValueType_Name(T value) {
    return ItemRule_ValueType_Name(value);
  }
  static inline bool ValueType_Parse(absl::string_view name, ValueType* value) {
    return ItemRule_ValueType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kRuleDataFieldNumber = 2,
    kRuleIdFieldNumber = 1,
    kItemRuleTypeFieldNumber = 3,
    kValueTypeFieldNumber = 4,
  };
  // bytes rule_data = 2;
  void clear_rule_data() ;
  const std::string& rule_data() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_rule_data(Arg_&& arg, Args_... args);
  std::string* mutable_rule_data();
  PROTOBUF_NODISCARD std::string* release_rule_data();
  void set_allocated_rule_data(std::string* ptr);

  private:
  const std::string& _internal_rule_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rule_data(
      const std::string& value);
  std::string* _internal_mutable_rule_data();

  public:
  // uint32 rule_id = 1;
  void clear_rule_id() ;
  ::uint32_t rule_id() const;
  void set_rule_id(::uint32_t value);

  private:
  ::uint32_t _internal_rule_id() const;
  void _internal_set_rule_id(::uint32_t value);

  public:
  // .msg.business.ItemRule.ItemRuleType item_rule_type = 3;
  void clear_item_rule_type() ;
  ::msg::business::ItemRule_ItemRuleType item_rule_type() const;
  void set_item_rule_type(::msg::business::ItemRule_ItemRuleType value);

  private:
  ::msg::business::ItemRule_ItemRuleType _internal_item_rule_type() const;
  void _internal_set_item_rule_type(::msg::business::ItemRule_ItemRuleType value);

  public:
  // .msg.business.ItemRule.ValueType value_type = 4;
  void clear_value_type() ;
  ::msg::business::ItemRule_ValueType value_type() const;
  void set_value_type(::msg::business::ItemRule_ValueType value);

  private:
  ::msg::business::ItemRule_ValueType _internal_value_type() const;
  void _internal_set_value_type(::msg::business::ItemRule_ValueType value);

  public:
  // @@protoc_insertion_point(class_scope:msg.business.ItemRule)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rule_data_;
    ::uint32_t rule_id_;
    int item_rule_type_;
    int value_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_5fbusiness_2eproto;
};// -------------------------------------------------------------------

class ItemRules final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.business.ItemRules) */ {
 public:
  inline ItemRules() : ItemRules(nullptr) {}
  ~ItemRules() override;
  explicit PROTOBUF_CONSTEXPR ItemRules(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ItemRules(const ItemRules& from);
  ItemRules(ItemRules&& from) noexcept
    : ItemRules() {
    *this = ::std::move(from);
  }

  inline ItemRules& operator=(const ItemRules& from) {
    CopyFrom(from);
    return *this;
  }
  inline ItemRules& operator=(ItemRules&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ItemRules& default_instance() {
    return *internal_default_instance();
  }
  static inline const ItemRules* internal_default_instance() {
    return reinterpret_cast<const ItemRules*>(
               &_ItemRules_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ItemRules& a, ItemRules& b) {
    a.Swap(&b);
  }
  inline void Swap(ItemRules* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ItemRules* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ItemRules* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ItemRules>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ItemRules& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ItemRules& from) {
    ItemRules::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ItemRules* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "msg.business.ItemRules";
  }
  protected:
  explicit ItemRules(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemRuleFieldNumber = 2,
    kItemIdFieldNumber = 1,
  };
  // repeated .msg.business.ItemRule item_rule = 2;
  int item_rule_size() const;
  private:
  int _internal_item_rule_size() const;

  public:
  void clear_item_rule() ;
  ::msg::business::ItemRule* mutable_item_rule(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::msg::business::ItemRule >*
      mutable_item_rule();
  private:
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::msg::business::ItemRule>& _internal_item_rule() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::msg::business::ItemRule>* _internal_mutable_item_rule();
  public:
  const ::msg::business::ItemRule& item_rule(int index) const;
  ::msg::business::ItemRule* add_item_rule();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::msg::business::ItemRule >&
      item_rule() const;
  // uint32 item_id = 1;
  void clear_item_id() ;
  ::uint32_t item_id() const;
  void set_item_id(::uint32_t value);

  private:
  ::uint32_t _internal_item_id() const;
  void _internal_set_item_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:msg.business.ItemRules)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::msg::business::ItemRule > item_rule_;
    ::uint32_t item_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_5fbusiness_2eproto;
};// -------------------------------------------------------------------

class ItemCheckResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.business.ItemCheckResult) */ {
 public:
  inline ItemCheckResult() : ItemCheckResult(nullptr) {}
  ~ItemCheckResult() override;
  explicit PROTOBUF_CONSTEXPR ItemCheckResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ItemCheckResult(const ItemCheckResult& from);
  ItemCheckResult(ItemCheckResult&& from) noexcept
    : ItemCheckResult() {
    *this = ::std::move(from);
  }

  inline ItemCheckResult& operator=(const ItemCheckResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline ItemCheckResult& operator=(ItemCheckResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ItemCheckResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const ItemCheckResult* internal_default_instance() {
    return reinterpret_cast<const ItemCheckResult*>(
               &_ItemCheckResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ItemCheckResult& a, ItemCheckResult& b) {
    a.Swap(&b);
  }
  inline void Swap(ItemCheckResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ItemCheckResult* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ItemCheckResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ItemCheckResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ItemCheckResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ItemCheckResult& from) {
    ItemCheckResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ItemCheckResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "msg.business.ItemCheckResult";
  }
  protected:
  explicit ItemCheckResult(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using ResultType = ItemCheckResult_ResultType;
  static constexpr ResultType T_PROGRESS = ItemCheckResult_ResultType_T_PROGRESS;
  static constexpr ResultType T_RESULT = ItemCheckResult_ResultType_T_RESULT;
  static inline bool ResultType_IsValid(int value) {
    return ItemCheckResult_ResultType_IsValid(value);
  }
  static constexpr ResultType ResultType_MIN = ItemCheckResult_ResultType_ResultType_MIN;
  static constexpr ResultType ResultType_MAX = ItemCheckResult_ResultType_ResultType_MAX;
  static constexpr int ResultType_ARRAYSIZE = ItemCheckResult_ResultType_ResultType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ResultType_descriptor() {
    return ItemCheckResult_ResultType_descriptor();
  }
  template <typename T>
  static inline const std::string& ResultType_Name(T value) {
    return ItemCheckResult_ResultType_Name(value);
  }
  static inline bool ResultType_Parse(absl::string_view name, ResultType* value) {
    return ItemCheckResult_ResultType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kResultDataFieldNumber = 3,
    kItemIdFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // bytes result_data = 3;
  void clear_result_data() ;
  const std::string& result_data() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_result_data(Arg_&& arg, Args_... args);
  std::string* mutable_result_data();
  PROTOBUF_NODISCARD std::string* release_result_data();
  void set_allocated_result_data(std::string* ptr);

  private:
  const std::string& _internal_result_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_result_data(
      const std::string& value);
  std::string* _internal_mutable_result_data();

  public:
  // uint32 item_id = 1;
  void clear_item_id() ;
  ::uint32_t item_id() const;
  void set_item_id(::uint32_t value);

  private:
  ::uint32_t _internal_item_id() const;
  void _internal_set_item_id(::uint32_t value);

  public:
  // .msg.business.ItemCheckResult.ResultType type = 2;
  void clear_type() ;
  ::msg::business::ItemCheckResult_ResultType type() const;
  void set_type(::msg::business::ItemCheckResult_ResultType value);

  private:
  ::msg::business::ItemCheckResult_ResultType _internal_type() const;
  void _internal_set_type(::msg::business::ItemCheckResult_ResultType value);

  public:
  // @@protoc_insertion_point(class_scope:msg.business.ItemCheckResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr result_data_;
    ::uint32_t item_id_;
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_5fbusiness_2eproto;
};// -------------------------------------------------------------------

class ItemControlState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.business.ItemControlState) */ {
 public:
  inline ItemControlState() : ItemControlState(nullptr) {}
  ~ItemControlState() override;
  explicit PROTOBUF_CONSTEXPR ItemControlState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ItemControlState(const ItemControlState& from);
  ItemControlState(ItemControlState&& from) noexcept
    : ItemControlState() {
    *this = ::std::move(from);
  }

  inline ItemControlState& operator=(const ItemControlState& from) {
    CopyFrom(from);
    return *this;
  }
  inline ItemControlState& operator=(ItemControlState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ItemControlState& default_instance() {
    return *internal_default_instance();
  }
  static inline const ItemControlState* internal_default_instance() {
    return reinterpret_cast<const ItemControlState*>(
               &_ItemControlState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ItemControlState& a, ItemControlState& b) {
    a.Swap(&b);
  }
  inline void Swap(ItemControlState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ItemControlState* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ItemControlState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ItemControlState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ItemControlState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ItemControlState& from) {
    ItemControlState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ItemControlState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "msg.business.ItemControlState";
  }
  protected:
  explicit ItemControlState(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using ControlStateType = ItemControlState_ControlStateType;
  static constexpr ControlStateType T_UNKNOWN = ItemControlState_ControlStateType_T_UNKNOWN;
  static constexpr ControlStateType T_START = ItemControlState_ControlStateType_T_START;
  static constexpr ControlStateType T_STOP = ItemControlState_ControlStateType_T_STOP;
  static constexpr ControlStateType T_SUSPEND = ItemControlState_ControlStateType_T_SUSPEND;
  static constexpr ControlStateType T_RESTORE = ItemControlState_ControlStateType_T_RESTORE;
  static inline bool ControlStateType_IsValid(int value) {
    return ItemControlState_ControlStateType_IsValid(value);
  }
  static constexpr ControlStateType ControlStateType_MIN = ItemControlState_ControlStateType_ControlStateType_MIN;
  static constexpr ControlStateType ControlStateType_MAX = ItemControlState_ControlStateType_ControlStateType_MAX;
  static constexpr int ControlStateType_ARRAYSIZE = ItemControlState_ControlStateType_ControlStateType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ControlStateType_descriptor() {
    return ItemControlState_ControlStateType_descriptor();
  }
  template <typename T>
  static inline const std::string& ControlStateType_Name(T value) {
    return ItemControlState_ControlStateType_Name(value);
  }
  static inline bool ControlStateType_Parse(absl::string_view name, ControlStateType* value) {
    return ItemControlState_ControlStateType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kMaxReportNumFieldNumber = 2,
  };
  // .msg.business.ItemControlState.ControlStateType type = 1;
  void clear_type() ;
  ::msg::business::ItemControlState_ControlStateType type() const;
  void set_type(::msg::business::ItemControlState_ControlStateType value);

  private:
  ::msg::business::ItemControlState_ControlStateType _internal_type() const;
  void _internal_set_type(::msg::business::ItemControlState_ControlStateType value);

  public:
  // uint32 max_report_num = 2;
  void clear_max_report_num() ;
  ::uint32_t max_report_num() const;
  void set_max_report_num(::uint32_t value);

  private:
  ::uint32_t _internal_max_report_num() const;
  void _internal_set_max_report_num(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:msg.business.ItemControlState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int type_;
    ::uint32_t max_report_num_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_5fbusiness_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// GetItemRule

// uint32 item_id = 1;
inline void GetItemRule::clear_item_id() {
  _impl_.item_id_ = 0u;
}
inline ::uint32_t GetItemRule::item_id() const {
  // @@protoc_insertion_point(field_get:msg.business.GetItemRule.item_id)
  return _internal_item_id();
}
inline void GetItemRule::set_item_id(::uint32_t value) {
  _internal_set_item_id(value);
  // @@protoc_insertion_point(field_set:msg.business.GetItemRule.item_id)
}
inline ::uint32_t GetItemRule::_internal_item_id() const {
  return _impl_.item_id_;
}
inline void GetItemRule::_internal_set_item_id(::uint32_t value) {
  ;
  _impl_.item_id_ = value;
}

// -------------------------------------------------------------------

// ItemRule

// uint32 rule_id = 1;
inline void ItemRule::clear_rule_id() {
  _impl_.rule_id_ = 0u;
}
inline ::uint32_t ItemRule::rule_id() const {
  // @@protoc_insertion_point(field_get:msg.business.ItemRule.rule_id)
  return _internal_rule_id();
}
inline void ItemRule::set_rule_id(::uint32_t value) {
  _internal_set_rule_id(value);
  // @@protoc_insertion_point(field_set:msg.business.ItemRule.rule_id)
}
inline ::uint32_t ItemRule::_internal_rule_id() const {
  return _impl_.rule_id_;
}
inline void ItemRule::_internal_set_rule_id(::uint32_t value) {
  ;
  _impl_.rule_id_ = value;
}

// bytes rule_data = 2;
inline void ItemRule::clear_rule_data() {
  _impl_.rule_data_.ClearToEmpty();
}
inline const std::string& ItemRule::rule_data() const {
  // @@protoc_insertion_point(field_get:msg.business.ItemRule.rule_data)
  return _internal_rule_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ItemRule::set_rule_data(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.rule_data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:msg.business.ItemRule.rule_data)
}
inline std::string* ItemRule::mutable_rule_data() {
  std::string* _s = _internal_mutable_rule_data();
  // @@protoc_insertion_point(field_mutable:msg.business.ItemRule.rule_data)
  return _s;
}
inline const std::string& ItemRule::_internal_rule_data() const {
  return _impl_.rule_data_.Get();
}
inline void ItemRule::_internal_set_rule_data(const std::string& value) {
  ;


  _impl_.rule_data_.Set(value, GetArenaForAllocation());
}
inline std::string* ItemRule::_internal_mutable_rule_data() {
  ;
  return _impl_.rule_data_.Mutable( GetArenaForAllocation());
}
inline std::string* ItemRule::release_rule_data() {
  // @@protoc_insertion_point(field_release:msg.business.ItemRule.rule_data)
  return _impl_.rule_data_.Release();
}
inline void ItemRule::set_allocated_rule_data(std::string* value) {
  _impl_.rule_data_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.rule_data_.IsDefault()) {
          _impl_.rule_data_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:msg.business.ItemRule.rule_data)
}

// .msg.business.ItemRule.ItemRuleType item_rule_type = 3;
inline void ItemRule::clear_item_rule_type() {
  _impl_.item_rule_type_ = 0;
}
inline ::msg::business::ItemRule_ItemRuleType ItemRule::item_rule_type() const {
  // @@protoc_insertion_point(field_get:msg.business.ItemRule.item_rule_type)
  return _internal_item_rule_type();
}
inline void ItemRule::set_item_rule_type(::msg::business::ItemRule_ItemRuleType value) {
   _internal_set_item_rule_type(value);
  // @@protoc_insertion_point(field_set:msg.business.ItemRule.item_rule_type)
}
inline ::msg::business::ItemRule_ItemRuleType ItemRule::_internal_item_rule_type() const {
  return static_cast<::msg::business::ItemRule_ItemRuleType>(_impl_.item_rule_type_);
}
inline void ItemRule::_internal_set_item_rule_type(::msg::business::ItemRule_ItemRuleType value) {
  ;
  _impl_.item_rule_type_ = value;
}

// .msg.business.ItemRule.ValueType value_type = 4;
inline void ItemRule::clear_value_type() {
  _impl_.value_type_ = 0;
}
inline ::msg::business::ItemRule_ValueType ItemRule::value_type() const {
  // @@protoc_insertion_point(field_get:msg.business.ItemRule.value_type)
  return _internal_value_type();
}
inline void ItemRule::set_value_type(::msg::business::ItemRule_ValueType value) {
   _internal_set_value_type(value);
  // @@protoc_insertion_point(field_set:msg.business.ItemRule.value_type)
}
inline ::msg::business::ItemRule_ValueType ItemRule::_internal_value_type() const {
  return static_cast<::msg::business::ItemRule_ValueType>(_impl_.value_type_);
}
inline void ItemRule::_internal_set_value_type(::msg::business::ItemRule_ValueType value) {
  ;
  _impl_.value_type_ = value;
}

// -------------------------------------------------------------------

// ItemRules

// uint32 item_id = 1;
inline void ItemRules::clear_item_id() {
  _impl_.item_id_ = 0u;
}
inline ::uint32_t ItemRules::item_id() const {
  // @@protoc_insertion_point(field_get:msg.business.ItemRules.item_id)
  return _internal_item_id();
}
inline void ItemRules::set_item_id(::uint32_t value) {
  _internal_set_item_id(value);
  // @@protoc_insertion_point(field_set:msg.business.ItemRules.item_id)
}
inline ::uint32_t ItemRules::_internal_item_id() const {
  return _impl_.item_id_;
}
inline void ItemRules::_internal_set_item_id(::uint32_t value) {
  ;
  _impl_.item_id_ = value;
}

// repeated .msg.business.ItemRule item_rule = 2;
inline int ItemRules::_internal_item_rule_size() const {
  return _impl_.item_rule_.size();
}
inline int ItemRules::item_rule_size() const {
  return _internal_item_rule_size();
}
inline void ItemRules::clear_item_rule() {
  _internal_mutable_item_rule()->Clear();
}
inline ::msg::business::ItemRule* ItemRules::mutable_item_rule(int index) {
  // @@protoc_insertion_point(field_mutable:msg.business.ItemRules.item_rule)
  return _internal_mutable_item_rule()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::msg::business::ItemRule >*
ItemRules::mutable_item_rule() {
  // @@protoc_insertion_point(field_mutable_list:msg.business.ItemRules.item_rule)
  return _internal_mutable_item_rule();
}
inline const ::msg::business::ItemRule& ItemRules::item_rule(int index) const {
  // @@protoc_insertion_point(field_get:msg.business.ItemRules.item_rule)
    return _internal_item_rule().Get(index);
}
inline ::msg::business::ItemRule* ItemRules::add_item_rule() {
  ::msg::business::ItemRule* _add = _internal_mutable_item_rule()->Add();
  // @@protoc_insertion_point(field_add:msg.business.ItemRules.item_rule)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::msg::business::ItemRule >&
ItemRules::item_rule() const {
  // @@protoc_insertion_point(field_list:msg.business.ItemRules.item_rule)
  return _internal_item_rule();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::msg::business::ItemRule>&
ItemRules::_internal_item_rule() const {
  return _impl_.item_rule_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::msg::business::ItemRule>*
ItemRules::_internal_mutable_item_rule() {
  return &_impl_.item_rule_;
}

// -------------------------------------------------------------------

// ItemCheckResult

// uint32 item_id = 1;
inline void ItemCheckResult::clear_item_id() {
  _impl_.item_id_ = 0u;
}
inline ::uint32_t ItemCheckResult::item_id() const {
  // @@protoc_insertion_point(field_get:msg.business.ItemCheckResult.item_id)
  return _internal_item_id();
}
inline void ItemCheckResult::set_item_id(::uint32_t value) {
  _internal_set_item_id(value);
  // @@protoc_insertion_point(field_set:msg.business.ItemCheckResult.item_id)
}
inline ::uint32_t ItemCheckResult::_internal_item_id() const {
  return _impl_.item_id_;
}
inline void ItemCheckResult::_internal_set_item_id(::uint32_t value) {
  ;
  _impl_.item_id_ = value;
}

// .msg.business.ItemCheckResult.ResultType type = 2;
inline void ItemCheckResult::clear_type() {
  _impl_.type_ = 0;
}
inline ::msg::business::ItemCheckResult_ResultType ItemCheckResult::type() const {
  // @@protoc_insertion_point(field_get:msg.business.ItemCheckResult.type)
  return _internal_type();
}
inline void ItemCheckResult::set_type(::msg::business::ItemCheckResult_ResultType value) {
   _internal_set_type(value);
  // @@protoc_insertion_point(field_set:msg.business.ItemCheckResult.type)
}
inline ::msg::business::ItemCheckResult_ResultType ItemCheckResult::_internal_type() const {
  return static_cast<::msg::business::ItemCheckResult_ResultType>(_impl_.type_);
}
inline void ItemCheckResult::_internal_set_type(::msg::business::ItemCheckResult_ResultType value) {
  ;
  _impl_.type_ = value;
}

// bytes result_data = 3;
inline void ItemCheckResult::clear_result_data() {
  _impl_.result_data_.ClearToEmpty();
}
inline const std::string& ItemCheckResult::result_data() const {
  // @@protoc_insertion_point(field_get:msg.business.ItemCheckResult.result_data)
  return _internal_result_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ItemCheckResult::set_result_data(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.result_data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:msg.business.ItemCheckResult.result_data)
}
inline std::string* ItemCheckResult::mutable_result_data() {
  std::string* _s = _internal_mutable_result_data();
  // @@protoc_insertion_point(field_mutable:msg.business.ItemCheckResult.result_data)
  return _s;
}
inline const std::string& ItemCheckResult::_internal_result_data() const {
  return _impl_.result_data_.Get();
}
inline void ItemCheckResult::_internal_set_result_data(const std::string& value) {
  ;


  _impl_.result_data_.Set(value, GetArenaForAllocation());
}
inline std::string* ItemCheckResult::_internal_mutable_result_data() {
  ;
  return _impl_.result_data_.Mutable( GetArenaForAllocation());
}
inline std::string* ItemCheckResult::release_result_data() {
  // @@protoc_insertion_point(field_release:msg.business.ItemCheckResult.result_data)
  return _impl_.result_data_.Release();
}
inline void ItemCheckResult::set_allocated_result_data(std::string* value) {
  _impl_.result_data_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.result_data_.IsDefault()) {
          _impl_.result_data_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:msg.business.ItemCheckResult.result_data)
}

// -------------------------------------------------------------------

// ItemControlState

// .msg.business.ItemControlState.ControlStateType type = 1;
inline void ItemControlState::clear_type() {
  _impl_.type_ = 0;
}
inline ::msg::business::ItemControlState_ControlStateType ItemControlState::type() const {
  // @@protoc_insertion_point(field_get:msg.business.ItemControlState.type)
  return _internal_type();
}
inline void ItemControlState::set_type(::msg::business::ItemControlState_ControlStateType value) {
   _internal_set_type(value);
  // @@protoc_insertion_point(field_set:msg.business.ItemControlState.type)
}
inline ::msg::business::ItemControlState_ControlStateType ItemControlState::_internal_type() const {
  return static_cast<::msg::business::ItemControlState_ControlStateType>(_impl_.type_);
}
inline void ItemControlState::_internal_set_type(::msg::business::ItemControlState_ControlStateType value) {
  ;
  _impl_.type_ = value;
}

// uint32 max_report_num = 2;
inline void ItemControlState::clear_max_report_num() {
  _impl_.max_report_num_ = 0u;
}
inline ::uint32_t ItemControlState::max_report_num() const {
  // @@protoc_insertion_point(field_get:msg.business.ItemControlState.max_report_num)
  return _internal_max_report_num();
}
inline void ItemControlState::set_max_report_num(::uint32_t value) {
  _internal_set_max_report_num(value);
  // @@protoc_insertion_point(field_set:msg.business.ItemControlState.max_report_num)
}
inline ::uint32_t ItemControlState::_internal_max_report_num() const {
  return _impl_.max_report_num_;
}
inline void ItemControlState::_internal_set_max_report_num(::uint32_t value) {
  ;
  _impl_.max_report_num_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace business
}  // namespace msg


PROTOBUF_NAMESPACE_OPEN

template <>
struct is_proto_enum<::msg::business::ItemRule_ItemRuleType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::msg::business::ItemRule_ItemRuleType>() {
  return ::msg::business::ItemRule_ItemRuleType_descriptor();
}
template <>
struct is_proto_enum<::msg::business::ItemRule_ValueType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::msg::business::ItemRule_ValueType>() {
  return ::msg::business::ItemRule_ValueType_descriptor();
}
template <>
struct is_proto_enum<::msg::business::ItemCheckResult_ResultType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::msg::business::ItemCheckResult_ResultType>() {
  return ::msg::business::ItemCheckResult_ResultType_descriptor();
}
template <>
struct is_proto_enum<::msg::business::ItemControlState_ControlStateType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::msg::business::ItemControlState_ControlStateType>() {
  return ::msg::business::ItemControlState_ControlStateType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_msg_5fbusiness_2eproto_2epb_2eh
